# 缓存策略之强缓存和协商缓存

> 浏览器缓存策略有强缓存和协商缓存

## 强缓存

通过 `max-age`、`public`、`immutable`三个字段来控制强缓存策略

* `max-age`：控制缓存过期时间
* `public`：控制是否可被代理服务器缓存
* `immutable`：控制缓存是否认为是不会改变的


组合如下：

* `cache-control: max-age=123 public immutable // 123秒内 客户端和代理服务器都可以缓存 假设不会改变（刷新浏览器也会取缓存）`
* `cache-control: max-age=123 private // 123秒内 客户端可以缓存，代理服务器不能缓存 刷新浏览器不会取缓存`
* `cache-control: no-cache 不使用强缓存，但是不妨碍设置协商缓存`
* `cache-control: no-store 强缓存和协商缓存都不使用`


## 协商缓存


比如我们强缓存设置了3天后过期，过期了以后，就会走真实的网络请求去服务端拿资源，但是服务端的资源是否真的过期了？如果没过期，不就浪费了网络io吗，为了解决这个问题，协商缓存出现了。

协商缓存通过两个字段：`etag、last-modified`来判断资源是否真的过期

* etag：每个文件有一个，文件的hash，改动文件了就变了
* last-modified：文件的上次修改时间，精确到秒

这两个字段在第一次真实请求资源时会由服务端设置，下次请求时浏览器会自动带上，通过这两个字段可以判断下次请求的资源是否在服务器上真的改变了。如果没变会返回304，客户端就会用老的资源

为什么要有etag？

你可能会觉得使用last-modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要etag呢？

etag是HTTP1.1中新增的，为了解决之前只有If-Modified的缺点，主要是为了解决如下几个last-modified的问题：

1. 一些文件也许会更改，但是他的内容并没有改变，仅仅是修改时间改变
2. 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，if-modified-since能检查到的粒度是秒级的，这种修改无法判断
3. 某些服务器不能精确的得到文件的最后修改时间。

所以，etag作为文件的hash，可配合last-modified完成更细粒度的缓存。
